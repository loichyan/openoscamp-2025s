# 脑洞

这里记录了学习过程中产生的一些思考和疑问．

## 优化 RISC-V 系统调用陷入处理

### 概览

本质上，陷入处理可以视为在程序中任意位置插入一条函数调用，而 RISC-V 的调用规范将寄存器分为 caller-saved 和 callee-saved[^1]，函数调用时编译器会自动帮我们维护这些寄存器的状态，基于此我们可以对系统调用做一些优化，以减少陷入处理前后存取上下文的访存操作．

### 用户态到内核态

在语义上，将用户态 `ecall` 规定为一个符合 C 调用规范的函数调用，从而

- 编译器在调用前会自动保存 caller-saved 寄存器
- 在执行服务函数时，编译器会自动保存 callee-saved 寄存器

因此，处理用户态 `ecall` 陷入时，只需要保存极个别寄存器即可．

#### 安全性

执行服务函数期间，内核可以自由使用 caller-saved 寄存器，返回用户态后，这些寄存器可能残留内核信息．一个可能的解决方案是，在返回用户态之前，将全部 caller-saved 寄存器置 0，这需要十几条汇编指令，但不需要任何访存．

### 内核到用户态 (异步化)

规定用户程序为一个 Rust `Future`，从内核转到用户态时，`poll` 此 `Future`，不考虑中断的情况下，每次执行用户程序就相当与一次函数调用，基于上文的讨论，编译器会帮我们在进入用户态之前保存 caller-saved 寄存器，而用户态 `poll` 时会保存 callee-saved 寄存器．

#### 安全性

执行 `poll` 时，用户态可以自由访问 callee-saved 寄存器，从而导致内核数据泄露，并且恶意程序可以修改这些寄存器，从而破坏内核的执行．因此，对于非可信用户程序，进入用户态前后必须保存 callee-saved 寄存器．

[^1]: <https://en.wikichip.org/wiki/risc-v/registers>
